# 1. Calculate ALL derived columns (we'll filter later)
df['get_offer_price'] = (df['offer_price'] - df['buy_base_price']).round(2)
df['depth_value'] = (df['offer_base_price'] - df['offer_price']).round(2)
df['depth_per-off'] = np.where(
    df['get_base_price'] == 0,
    100,
    ((df['get_base_price'] - df['get_offer_price']) / df['get_base_price'] * 100).round(2)
)

# 2. Simplified validation function
def validate_row(row):
    mechanic = row['mechanic']
    validation_passed = True
    reason_true_false = []
    
    # Price Ending Group A Validations
    if mechanic in ['atpp', 'mmmix', 'mmmatch', 'ct', 'ap']:
        valid, expected = is_valid_price_ending(row['offer_price'])
        if valid:
            reason_true_false.append(f"{expected:.2f}")
        else:
            validation_passed = False
    
    # get_offer_price Validations
    if mechanic in ['bogomatch', 'bogomix', 'bg', 'satpp']:
        valid, expected = is_valid_price_ending(row['get_offer_price'])
        if valid:
            reason_true_false.append(f"{expected:.2f}")
        else:
            validation_passed = False
    
    # Money Off Validations
    if mechanic in ['satdoff', 'dollar-off']:
        valid, expected = is_valid_money_off(row['depth_value'])
        if valid:
            reason_true_false.append(f"{expected:.2f}")
        else:
            validation_passed = False
    
    # Percentage Off Validations
    if mechanic in ['bogomix_per-off', 'bogomatch_per-off', 'bg_per-off', 'per-off']:
        field = 'depth_per-off' if 'per-off' in mechanic else 'depth'
        valid, expected = is_valid_percentage(row[field])
        if valid:
            reason_true_false.append(f"{int(expected)}%")
        else:
            validation_passed = False
    
    # Component Validations (CT/AP)
    if mechanic in ['ct', 'ap']:
        valid, expected = validate_component(mechanic, row['component'])
        if not valid:
            validation_passed = False
    
    # Order Mechanic Validations
    if mechanic in ['order_per-off', 'order_dollar-off']:
        valid, expected = validate_component(mechanic, row['component'])
        if not valid:
            validation_passed = False
        if mechanic == 'order_per-off':
            valid, expected = is_valid_percentage(float(row['setX']))
            if valid:
                reason_true_false.append(f"{int(expected)}%")
        elif mechanic == 'order_dollar-off':
            valid, expected = is_valid_money_off(float(row['setX']))
            if valid:
                reason_true_false.append(f"{expected:.2f}")
    
    return pd.Series({
        'validation_flag': validation_passed,
        'reason_true_false': ", ".join(reason_true_false) if reason_true_false else ""
    })

# Apply validation
validation_results = df.apply(validate_row, axis=1)
df = pd.concat([df, validation_results], axis=1)

# Filter derived columns for relevant mechanics only
def filter_derived_values(row):
    mechanic = row['mechanic']
    bogo_mechs = ['bogomatch', 'bogomix', 'bg', 'satpp']
    money_mechs = ['satdoff', 'dollar-off']
    pct_mechs = ['bogomix_per-off', 'bogomatch_per-off', 'bg_per-off', 'per-off']
    
    if mechanic not in bogo_mechs: row['get_offer_price'] = None
    if mechanic not in money_mechs: row['depth_value'] = None
    if mechanic not in pct_mechs: row['depth_per-off'] = None
    return row

df = df.apply(filter_derived_values, axis=1)

# Clean up and save
df = df.drop(columns=['dd', 'mechanic', 'component', 'setX', 'hashtag'], errors='ignore')
df.to_parquet('final_validated_prices.parquet', index=False)
