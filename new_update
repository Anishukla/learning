import pandas as pd
import numpy as np

# Load data
df = pd.read_parquet('your_file_path.parquet')

# Calculate ALL potential derived columns (we'll filter later)
df['get_offer_price'] = (df['offer_price'] - df['buy_base_price']).round(2)
df['depth_value'] = (df['offer_base_price'] - df['offer_price']).round(2)
df['depth_per-off'] = np.where(
    df['get_base_price'] == 0,
    100,
    ((df['get_base_price'] - df['get_offer_price']) / df['get_base_price'] * 100).round(2)
)

# Split ID column
df[['dd', 'mechanic', 'component', 'setX', 'hashtag']] = df['idv_id'].str.split('_', expand=True)

# Convert depth to percentage
df['depth'] = (df['depth'] * 100).round(2)

# Define validation functions
def is_valid_price_ending(price):
    fractional = round(price % 1, 2)
    valid_endings = {0.00, 0.29, 0.39, 0.49, 0.50, 0.59, 0.69, 0.79, 0.99}
    return fractional in valid_endings, fractional

def is_valid_money_off(value):
    fractional = round(value % 1, 2)
    return fractional in {0.00, 0.50}, fractional

def is_valid_percentage(value):
    return value % 5 == 0, value

def validate_component(mechanic, component):
    if mechanic == 'ct':
        return component.isdigit(), component
    elif mechanic == 'ap':
        return component == '0', component
    elif mechanic in ['order_per-off', 'order_dollar-off']:
        return component.isdigit(), component
    return True, component

# Master validation function
def validate_row(row):
    mechanic = row['mechanic']
    validation_passed = True
    reasons = []
    true_values = []
    
    # Price Ending Group A Validations
    if mechanic in ['atpp', 'mmmix', 'mmmatch', 'ct', 'ap']:
        valid, expected = is_valid_price_ending(row['offer_price'])
        if not valid:
            validation_passed = False
            reasons.append(f"{mechanic}_offer_price_False_{row['offer_price']}")
        else:
            true_values.append(f"{mechanic}_offer_price_True_{expected}")
    
    # get_offer_price Validations
    if mechanic in ['bogomatch', 'bogomix', 'bg', 'satpp']:
        valid, expected = is_valid_price_ending(row['get_offer_price'])
        if not valid:
            validation_passed = False
            reasons.append(f"{mechanic}_get_offer_price_False_{row['get_offer_price']}")
        else:
            true_values.append(f"{mechanic}_get_offer_price_True_{expected}")
    
    # Money Off Validations
    if mechanic in ['satdoff', 'dollar-off']:
        valid, expected = is_valid_money_off(row['depth_value'])
        if not valid:
            validation_passed = False
            reasons.append(f"{mechanic}_depth_value_False_{row['depth_value']}")
        else:
            true_values.append(f"{mechanic}_depth_value_True_{expected}")
    
    # Percentage Off Validations
    if mechanic in ['bogomix_per-off', 'bogomatch_per-off', 'bg_per-off', 'per-off']:
        field = 'depth_per-off' if 'per-off' in mechanic else 'depth'
        valid, expected = is_valid_percentage(row[field])
        if not valid:
            validation_passed = False
            reasons.append(f"{mechanic}_{field}_False_{row[field]}")
        else:
            true_values.append(f"{mechanic}_{field}_True_{expected}")
    
    # Component Validations
    if mechanic in ['ct', 'ap', 'order_per-off', 'order_dollar-off']:
        valid, expected = validate_component(mechanic, row['component'])
        if not valid:
            validation_passed = False
            reasons.append(f"{mechanic}_component_False_{row['component']}")
        else:
            true_values.append(f"{mechanic}_component_True_{expected}")
    
    # Order Mechanic Additional Validations
    if mechanic == 'order_per-off':
        valid, expected = is_valid_percentage(float(row['setX']))
        if not valid:
            validation_passed = False
            reasons.append(f"{mechanic}_setX_False_{row['setX']}")
        else:
            true_values.append(f"{mechanic}_setX_True_{expected}")
    
    if mechanic == 'order_dollar-off':
        valid, expected = is_valid_money_off(float(row['setX']))
        if not valid:
            validation_passed = False
            reasons.append(f"{mechanic}_setX_False_{row['setX']}")
        else:
            true_values.append(f"{mechanic}_setX_True_{expected}")
    
    return pd.Series({
        'validation_flag': validation_passed,
        'reason': "; ".join(reasons) if not validation_passed else "All valid",
        'true_values': "; ".join(true_values) if true_values else ""
    })

# Apply validation
validation_results = df.apply(validate_row, axis=1)
df = pd.concat([df, validation_results], axis=1)

# Filter derived columns for relevant mechanics only
def filter_derived_values(row):
    mechanic = row['mechanic']
    
    # Define which mechanics use which derived columns
    bogo_mechanics = ['bogomatch', 'bogomix', 'bg', 'satpp']
    money_off_mechanics = ['satdoff', 'dollar-off']
    percent_off_mechanics = ['bogomix_per-off', 'bogomatch_per-off', 'bg_per-off', 'per-off']
    
    if mechanic not in bogo_mechanics:
        row['get_offer_price'] = None
    if mechanic not in money_off_mechanics:
        row['depth_value'] = None
    if mechanic not in percent_off_mechanics:
        row['depth_per-off'] = None
        
    return row

df = df.apply(filter_derived_values, axis=1)

# Drop temporary columns
df = df.drop(columns=['dd', 'mechanic', 'component', 'setX', 'hashtag'], errors='ignore')

# Save final output
df.to_parquet('complete_validated_prices.parquet', index=False)
